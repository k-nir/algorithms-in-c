#include <stdio.h>
#include <stdlib.h>
#include "connectivity.h"

/****************************************
 * @ingroup Connectivity
 * @defgroup QuickFind
 * @brief 连接问题算法1: Quick-find算法。
 * 
 * ###数据结构#
 * 
 * Quick-find算法用数组存储连接信息。
 * 
 * 具体来说，数组分为两个部分:
 * - 元素
 * - 元素的值
 * 
 * Quick-find算法用数组元素本身代表对象(对象可以被抽象为整数)，
 * 序号为0的元素代表0对象，序号为1的元素代表1对象，以此类推。
 * 
 * 用元素的值表示对象间的连接关系，
 * 有连接关系的两个对象的值相同(即属于同一个集合)，没有连接关系的两个对象的值不同(即不属于同一个集合)。
 * 
 * ###算法描述#
 * 
 * 算法的执行步骤如下:
 * 
 * -# 初始化数组
 *    
 *    在开始接受输入之前，连接程序不知道对象间的任何连接关系，
 *    所以此时存储连接信息的数组中不应含有任何值相同的元素，
 *    即数组中每个元素的值都必需是唯一的。
 *    
 *    要使数组的每个元素具有唯一的值，最简单的方法是让元素的值等于元素的序号，
 *    本文的算法实现就采取此办法。
 *    
 *    初始化后，可以认为数组的每个元素都独立构成一个无连接集合。
 * 
 * -# 接受输入，检查输入的对象对是否已连接
 *    
 *    要知道输入的对象对是否已连接，只需检查与两个对象对应的元素的值是否相等。
 *    
 *    输入的对象以整数表示，以该整数值为序号的数组元素就是与对象对应的元素。
 *    因此，只需按序号读取两个数组元素，即可知道两者是否已连接。
 *    
 *    本步骤与抽象操作中的 **搜索** 操作对应，本算法之所以叫做"Quick-find"，
 *    就是因为搜索操作的速度非常快(是O(1)操作)。
 * 
 * -# 对象对已连接时，什么也不做
 *    
 *    与输入对中的两个对象对应的数组元素的值相等就表示对象已连接。
 *    
 * -# 对象未连接时，连接对象，并打印输出
 *    
 *    将两个对象连接到一起，就是使两个对象属于同一个集合，
 *    也就是使与对象对应的两个数组元素具有相同的值，且该值与所有表示其他集合的值相异。
 *    
 *    注意，对象间的连接具有传递性，假设在需要建立新连接的输入对3-7中，3已与2, 4, 6连接，
 *    则建立新连接时，序号为7的元素的值不但要与序号为3的元素的值相等，还要与需要为2, 4, 6的元素的值相等，
 *    即序号为2, 3, 4, 6, 7的元素的值必须都相等(也就是同一个集合下的所有元素的值必须相等)。
 *    
 *    从以上描述可以看出，建立新连接时要保证两个条件成立:
 *    -# 同一集合下所有元素的值相等。
 *    -# 不同集合的元素的值不同。
 *    .
 *    建立新连接对集合可能产生的影响有3种:
 *    -# 两个之前从未有过任何连接的对象连接时，会导致新有连接集合的产生。
 *    -# 一个之前有过连接的对象与一个之前没有过连接的对象连接时，会使有过连接的对象所属的有连接集合添加一个新的元素。
 *    -# 两个之前都有过连接的对象连接时，会使两个有连接集合合并成一个集合。
 *    .
 *    此处如果把没有连接关系的对象视为一个无连接集合，以上三种情况就能被化约为一种情况，
 *    即任何新连接的建立都会使两个集合(有连接集合或无连接集合)合并成一个有连接集合。
 *    
 *    要在合并集合的同时保持两个条件成立，必须实现以下操作:
 *    -# 挑选出一个与其他集合都相异的值。
 *    -# 找出新集合的所有元素。
 *    -# 使新集合所有元素的值都等于之前挑选的值。
 *    .
 *    实现第一个操作最简单的方法是在要合并的两个集合中挑选任意一个集合的值作为新集合的值，
 *    本算法实现总是选择输入对中后一个对象所在的集合的值作新集合的值。
 *    
 *    要证明这个方法是可靠的，可做如下推理。
 * 
 *    每个元素的初值都是自己的序号，若将两个具有初值的元素(即原来没有连接关系的元素)组成一个有连接集合，
 *    并用其中一个元素的值作集合的值，则新集合中一定会有一个值和序号仍然相等的元素。
 *    因此，前述方法在两个无连接集合连接成一个有连接集合的情况下是可靠的。
 *    
 *    一个只具有两个元素的有连接集合(只有两个元素的集合必然是两个无连接集合合并成的，因此其中一个元素的值必然等于自身的序号)纳入一个具有初值的元素组形成新集合时，
 *    新集合的值有两种情况:
 *    -# 等于原有连接集合的值\n
 *       这种情况下，原有连接集合中值等于自身序号的那个元素保持不变，新加入元素的值改变。
 *    -# 等于新加入元素的值\n
 *       这种情况下，原有连接集合中两个元素的值都改变，新加入元素的值不变，仍等于自己的序号。
 *    .
 *    可见，两种情况下，新集合中都会有一个值等于自己序号的元素。
 *    因此，前述方法在一个具有两个元素的有连接集合与一个无连接集合合并的情况下是可靠的。   
 * 
 *    两个只具有两个元素的有连接集合合并成一个新集合时，新集合的值必然等与两个有连接集合之一的值，
 *    而这两个有连接集合中都必然包含一个值与序号相等的元素，因此新集合的值一定与这两个值与序号相等的元素之一的值相等，
 *    故新集合一定包含一个值与序号相等的元素。
 *    因此，前述方法在两个具有两个元素的有连接集合合并的情况下是可靠的。
 *    
 *    至此，我们已证明了前述方法在一对一(两个只含有一个元素的集合)，二对一(一个含有两个元素的集合和一个只有单个元素的集合)，
 *    二对二(两个含有两个元素的集合)的合并下都是可靠的，其他所有的情况都可以拆解成这三种情况的组合(例如: 四对三合并就是一个二对二合并加一个二对一合并)，
 *    因此，可以肯定前述方法在所有情况下都是可靠的。
 *    
 *    找出新集合的所有元素，就是找出输入对中的对象各自所属的集合中的所有元素，
 *    由于本算法的数据结构中没有存储集合的任何metadata(例如: 集合中元素的个数等)，
 *    所以找出所有集合元素只能通过从头到尾遍历整个数组实现。
 *    
 *    同理，使新集合的所有元素等于挑选出的值也只能通过遍历整个数组实现。
 * 
 *    由于我们选择用输入对后一个对象的值从当新数组的值，
 *    所以实际上新集合中原本属于后一个对象所在的集合的元素的值是不用修改的，
 *    因此我们只需要找出前一个对象所属的集合中的元素，
 *    不过这仍然需要遍历整个数组。
 *    
 *    本步骤进行的操作就是抽象操作中的 **联合** 操作，综合上文，在Quick-find算法中进行一次联合操作，需要经过以下步骤:
 *    -# 选择与输入对后一个对象对应的数组元素的值作新集合的值。
 *    -# 遍历数组，找出所有与输入对中前一个对象的值相等的项。
 *    -# 将找到的对象的值改为输入对后一个对象的值。
 *    .
 *    可见，Quick-find算法的联合操作开销是比较大的。
 * 
 * -# 等待下一个输入
 * 
 * ###状态迁移#
 * 
 * 初始状态
 * - 逻辑图
 * @dotfile quick-find-graph-0.gv
 * - 实际数组
 * @dotfile quick-find-array-0.gv
 * 
 * 输入: 输入连接2-3\n
 * 结果: 将集合{2}和{3}合并成{2, 3}
 * - 逻辑图
 * @dotfile quick-find-graph-1.gv
 * - 实际数组
 * @dotfile quick-find-array-1.gv
 * 
 * 输入: 输入连接5-7\n
 * 结果: 将集合{5}和{7}合并成{5, 7}
 * - 逻辑图
 * @dotfile quick-find-graph-2.gv
 * - 实际数组
 * @dotfile quick-find-array-2.gv
 * 
 * 输入: 输入连接5-0\n
 * 结果: 将集合{5, 7}和{0}合并成{0, 5, 7}
 * - 逻辑图
 * @dotfile quick-find-graph-3.gv
 * - 实际数组
 * @dotfile quick-find-array-3.gv
 * 
 * 输入: 输入连接0-3\n
 * 结果: 将集合{0, 5, 7}和{2, 3}合并成{0, 2, 3, 5, 7}
 * - 逻辑图
 * @dotfile quick-find-graph-4.gv
 * - 实际数组
 * @dotfile quick-find-array-4.gv
 * 
 * 输入: 输入连接7-3\n
 * 结果: 连接已存在
 * - 逻辑图
 * @dotfile quick-find-graph-5.gv
 * - 实际数组
 * @dotfile quick-find-array-5.gv
 * 
 * 
 * @{
 ****************************************/

#ifdef DOC_COMPILE

/**
 * @brief Quick-find算法实现
 * 
 * ###效率计算#
 * 
 * Quick-find算法处理一个输入对时，首先比较与输入对对应的数组元素的值是否相等，
 * 这个过程只涉及两次取值和一次比较，消耗的时间可以忽略不计。
 * 
 * 如果输入对代表的连接关系是新的，则Quick-find算法需要从头到尾遍历一边数组才能完成一次联合操作。
 * 
 * 据此，假设对象共有N个，输入连接程序的全新的连接关系共有M个，
 * 则使用Quick-find算法的连接程序需要MN个单位时间，才能处理完所有输入。
 */
int main() 
{
    int i, p, q, t, id[N];
    // 初始化数组
    for (i = 0; i < N; i++) id[i] = i;
    // 读取输入对
    /* 书中使用的scanf格式字符串为"%d %d\n"，
     "\n"会导致scanf消耗掉输入流中的换行符，
     使换行符不能刷新缓冲区。*/
    while (scanf("%d %d", &p, &q) == 2) 
    {
        // 搜索操作: 检查输入队中的对象是否属于同一个集合
        // 属于同一个集合时，什么也不做，等待下一个输入。
        if (id[p] == id[q]) continue;
        // 联合操作: 不属于同一个集合时，从头到尾遍历数组
        for (t = id[p], i = 0; i < N; i++) 
        {
            // 联合操作: 找出与输入对前一个对象同属一个集合的元素，将这些元素的值改为输入对后一个对象的值
            if (id[i] == t) id[i] = id[q];
        }
        // 打印新连接关系
        printf(" %d %d\n", p, q);
    }

    return 0;
}

#else // #ifdef DOC_COMPILE

static void qfind_find_operation(int *storage, int p, int q, int *psetval, int *qsetval);
static void qfind_union_operation(int *storage, size_t object_num, int psetval, int qsetval);

int *qfind_new_storage(size_t object_num) {
    int *storage = malloc(sizeof(*storage) * object_num);
    if (storage != NULL) for (size_t i = 0; i < object_num; i++) storage[i] = i;
    return storage;
}

void qfind_delete_storage(int *storage) {
    if (storage != NULL) free(storage);
    return;
}

bool qfind_is_new_connection(int *storage, size_t object_num, int p, int q) {
    int psetval, qsetval;
    qfind_find_operation(storage, p, q, &psetval, &qsetval);
    if (psetval == qsetval) return false;
    qfind_union_operation(storage, object_num, psetval, qsetval);
    return true;
}

static void qfind_find_operation(int *storage, int p, int q, int *psetval, int *qsetval) {
    *psetval = storage[p];
    *qsetval = storage[q];
    return;
}

static void qfind_union_operation(int *storage, size_t object_num, int psetval, int qsetval) {
    for (int i = 0; i < object_num; i++) if (storage[i] == psetval) storage[i] = qsetval;
    return;
}

#endif // #ifdef DOC_COMPILE

/****************************************
 * @} -- QuickFind
 ****************************************/